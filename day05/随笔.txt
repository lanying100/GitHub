运算符
算数运算符   + - * / % ++ --
赋值运算符  = += -= *= /= %=    x = x + 5; x += 5; 
关系运算符  > < >=  <= == != 
逻辑运算符（true or false）  && || ! & | ^
短路与：条件1 && 条件2
短路或：条件1 || 条件2
if(条件1 && 条件2 || 条件3){
     // 买包子吃
}
if(!(条件1 || 条件2)){
     // 买饮料
}
!true
^ 异或 一真一假则为true
龙凤胎：true+false --> true
位运算符（0 or 1）：& | ^ ~
&: 1&1==1; 1&0==0; 0&0==0; 0&1==0; 0 意味着false
| :  1|1==1;1|0==1;0|1==1;0|0==0; 1意味着true
^:1^1==0;1^0==1;0^1==1;0^0==0;不同则为1
~:~1==0;~0==1; 取反
~（1&0|1^0）

++
int c = 3;
c++;// 自增 单目运算符   3+4
++c;//
c  = ? c == 4
单独使用时，++c和c++没有效果上的区别
带赋值运算时，
int c = 3;
int d = c ++;//c == 4; d == 3;(自增之前的c)

int c = 3;
int d = ++ c;//c == 4; d == 4;(自增之后的c)

十进制：0~9 满十进一  千百十个
986
二进制：0~1 满二进一  八四二一
0b 1010
0b 0000
0b 0001
0b 0010
0b 0011
0b 0100
0b 0101  5
0b 0110  6
0b 0111  7
0b 1000  8
......
0b 1111  15

13 0b 1101


原码、反码、补码
补码：为了解决【负数】问题提出的

原码求补码：取反+1
补码求原码：取反+1
原因：原码和补码拼起来正好是【一圈】，补码的补码就是原码。

条件分支：
if-else
if - else if - else 最后的else可以省略
注意与 if ... if ... if ... 区分





